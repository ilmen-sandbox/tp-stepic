# Что происходит при HTTP запросе?

1. Браузер парсит URL (примем его за абсолютный для простоты), извлекаем имя хоста (домен), протокол (http, https)
2. Используя DNS преобразуем имя хоста (домен) в IP-адрес web-сервера
3. Устанавливаем TCP соединение с web-сервером
  1. Если используется HTTPs - устанавливаем TLS соединение (шифрованное и защищенное) поверх TCP
4. Формируем HTTP-запрос, отправляем его web-серверу, получаем документ-ответ
5. Пусть браузер закрывает соединение **(это для HTTP/1.0)**
6. Браузер загружает связанные ресурсы
  
## Стек сетевых протоколов
*Указаны не все уровни стека*
![stack](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/stack.png "стек сетевых протоколов")

* HTTPs+TLS: реализовано в userspace (браузер/web-сервер)
* TCP+IP: реализовано в ОС клиента/сервера

Запрос от браузера проходит по всем уровням стека на клиенской машине, передаются на сервер, на стороне сервера сообщение "поднимаются" по стеку вверх.

Т.е. передача по HTTP(s) - это передача сообщения на самом нижнем уровне, по с включением в стек уровней TLS и HTTP(s) (TLS использутся только при использовании HTTPs).

## DNS
**DNS** (Domain Name System) - это *распределенная база данных*, хранящая информацию о доменах, в первую очередь отображение доменных имен на IP адреса машин, обслуживающих эти домены.

### Пространство доменных имен
**Пространство доменных имен** - строки, состоящие из слов, разделенных точками. Домены образуют древовидную структуру.

Например, сайт *wikipedia* имеет домен: ru.wikipedia.org.  
0. Домен нулевого уровня: .  
*Обычно не указывается в URL*  
1. Домены первого уровня: ru, en, org, edu, ...  
*Практически статичное множество (например* ***ru*** *- Россия,* ***org*** *- организации,* ***edu*** *- образование)*  
2. Домены второго уровня: yandex, stepic, mail, wikipedia, ...  
*Примерно соответствуют организациям*  
3. Домены третьего уровня и т.д.

### Зоны
База DNS поделена на зоны. Каждая зона находиться под единым *административным* контролем (обслуживается *одной организацией*).  
В одну зону могут входить и домены одного уровня, так и некоторая иерархия доменов.  
Управление более высокоуровневыми или низкоуровневыми зонами может быть делегировано другим организациям.

![dns-zones](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/zones.png "Зоны DNS")  

### DNS запрос
DNS запросы производятся по специальному протоколу.  
На любом компьютере всегда **должен** быть прописан адрес DNS сервера (обычно, DNS-сервер организации или DNS-сервер провайдера).  
* Может быть задан вручную в настройках сетевого соединения
* Может быть получен по протоколу DHCP от роутера или провайдера
* Существует заранее известный список **корневых** DNS-серверов (те самые *ru*, *org* и т.п., их IP меняется очень редко и может быть закешировано на долго в недрах ОС)

Вот как происходит обработка запроса:
![dns-request](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/dnsreq.png "DNS запрос")  
Для **снижения нагрузки** на DNS-сервера (*особенно нагрузки на корневые DNS-сервера*) используется механизм **кеширования** ответов DNS-серверов на DNS-сервере провайдера, чтобы при последующих запросах не делегировать запросы к сторонним DNS-серверам, а сразу возвращать закешированные ответы.  
Также в ОС есть файл **hosts**, который предоставляет возможность задать жесткую связь домена и IP адреса. Файл hosts проверяется до обращения к локальному DNS-серверу.
 
 **Внимание:** для электронной почты используется другие DNS-сервера.

## TCP
Протокол IP не может обеспечить надежной доставки данных.  
TCP - протокол надежной доставки данных. Предоставляет протокол, схожий с файловым вводом/выводом.

### Свойства TCP:
* Надежная доставка  
  Если вы получили ответ "данные переданы", это означает что данные доставлены до клиента в том виде, в котором вы их передали (гарантируется проверкой контрольных сумм).  
  Если данные не вышло доставить, то протокол будет предпринимать попытки их доставить.  
  Если протокол "понимает" что данные доставить невозможно, он возвращает код ошибки, что сообщает нам о том, что передача не удалась.  
* Полнодуплексная передача  
  Передача данных в обе стороны.  
* Контроль потока - защита от переполнения буффера  
  При передачи контролируется условие, что передающая сторона передает данных не больше, чем получающая сторона может потребить.

### TCP порты
**TCP порт** - это «адрес» сетевого соединения в пределах одного хоста.  
TCP порты позволяют поддерживать множество открытых соединений на одной машине.  
**Номер порта** - целое неотрицательное число, **не больше 65535** (2 байта).  
***Порты ниже 1024 требуют привилегий суперпользователя для использования*** (актуально для UNIX-систем)  
Одним TCP портом может владеть не более одной программы.
Распределением портов занимается ОС.  

#### Стандартные TCP порты:
* 20,21 - FTP
* 22 - SSH
* 25 - SMTP
* 80 - HTTP
* 443 - HTTPS

#### Установление TCP соединения
При установлении TCP соединения клиент и сервер обмениваются 3 пакетами (*тройное рукопожатие*):

![haskshake](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/tcp.png "Установление TCP соединения")

1. Клиент отправлет сервера пакет с установленным флагом ***SYN*** и **случайным клиентским порядковым номером передачи**.  
   В дальнейшем, этот номер будет использоваться для защиты от подмены пакетов.
2. Сервер открывает ответное соединение и отправляет клиенту пакет с флагами ***SYN***, ***ACK*** и **случайным серверным порядковым номером передачи**.  
3. Клинет отвечает серверу пакетом ***ACK***, подтверждая прием от сервера порядкового номера передачи.

Теперь клиент и сервер имеет пару порядковых номеров передачи и открытое полнодуплексное соединение.  
С этого момента возможна передача данных.

**RTT** (round trim time) - время "путишествия" данных от клиента к серверу и обратно.  
Если клиент и сервер на разных континентах, то RTT может быть более 150 мс.

#### Пример TCP клиента  
import socket  
req = "Hello tcp!"  
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
s.connect(('127.0.0.1', 1234))    # здесь происходит тройное рукопожатие (может занимать долгое время, в 2xRTT)  
s.send(req)  
rsp = s.recv(1024)  
s.close()  

Сокет может использоват разные протоколы передачи:
* **AF_UNIX** - *передача данных в пределах одной UNIX-машины* (не через протокол IP)
* **AF_TIPC** - передача данных в пределах кластера (не через протокол IP)
* **AF_INET** - передача данных в локальной сети по протоколу IPv4
* **AF_INET6** - передача данных в локальной сети по протоколу IPv6

#### Пример TCP сервера
import socket  
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
s.bind(('127.0.0.1', 1234))  
s.listen(10)                # максимальное кол-во открытых соединений по данному endpoint  
while True:  
  conn, addr = s.accept()   # при подключении клиента получаем кортеж: соединение с клиентом + адрес клиента  
  while True:  
    data = conn.recv(1024)  # получаем данные из сокета по 1024 байт  
    if not data: break  
    conn.send(data)  
  conn.close()  









