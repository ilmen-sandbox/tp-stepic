# Что происходит при HTTP запросе?

1. Браузер парсит URL (примем его за абсолютный для простоты), извлекаем имя хоста (домен), протокол (http, https)
2. Используя DNS преобразуем имя хоста (домен) в IP-адрес web-сервера
3. Устанавливаем TCP соединение с web-сервером
  1. Если используется HTTPs - устанавливаем TLS соединение (шифрованное и защищенное) поверх TCP
4. Формируем HTTP-запрос, отправляем его web-серверу, получаем документ-ответ
5. Пусть браузер закрывает соединение **(это для HTTP/1.0)**
6. Браузер загружает связанные ресурсы
  
## Стек сетевых протоколов
*Указаны не все уровни стека*
![stack](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/stack.png "стек сетевых протоколов")

* HTTPs+TLS: реализовано в userspace (браузер/web-сервер)
* TCP+IP: реализовано в ОС клиента/сервера

Запрос от браузера проходит по всем уровням стека на клиенской машине, передаются на сервер, на стороне сервера сообщение "поднимаются" по стеку вверх.

Т.е. передача по HTTP(s) - это передача сообщения на самом нижнем уровне, по с включением в стек уровней TLS и HTTP(s) (TLS использутся только при использовании HTTPs).

## DNS
**DNS** (Domain Name System) - это *распределенная база данных*, хранящая информацию о доменах, в первую очередь отображение доменных имен на IP адреса машин, обслуживающих эти домены.

### Пространство доменных имен
**Пространство доменных имен** - строки, состоящие из слов, разделенных точками. Домены образуют древовидную структуру.

Например, сайт *wikipedia* имеет домен: ru.wikipedia.org.  
0. Домен нулевого уровня: .  
*Обычно не указывается в URL*  
1. Домены первого уровня: ru, en, org, edu, ...  
*Практически статичное множество (например* ***ru*** *- Россия,* ***org*** *- организации,* ***edu*** *- образование)*  
2. Домены второго уровня: yandex, stepic, mail, wikipedia, ...  
*Примерно соответствуют организациям*  
3. Домены третьего уровня и т.д.

### Зоны
База DNS поделена на зоны. Каждая зона находиться под единым *административным* контролем (обслуживается *одной организацией*).  
В одну зону могут входить и домены одного уровня, так и некоторая иерархия доменов.  
Управление более высокоуровневыми или низкоуровневыми зонами может быть делегировано другим организациям.

![dns-zones](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/zones.png "Зоны DNS")  

### DNS запрос
DNS запросы производятся по специальному протоколу.  
На любом компьютере всегда **должен** быть прописан адрес DNS сервера (обычно, DNS-сервер организации или DNS-сервер провайдера).  
* Может быть задан вручную в настройках сетевого соединения
* Может быть получен по протоколу DHCP от роутера или провайдера
* Существует заранее известный список **корневых** DNS-серверов (те самые *ru*, *org* и т.п., их IP меняется очень редко и может быть закешировано на долго в недрах ОС)

Вот как происходит обработка запроса:
![dns-request](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/dnsreq.png "DNS запрос")  
Для **снижения нагрузки** на DNS-сервера (*особенно нагрузки на корневые DNS-сервера*) используется механизм **кеширования** ответов DNS-серверов на DNS-сервере провайдера, чтобы при последующих запросах не делегировать запросы к сторонним DNS-серверам, а сразу возвращать закешированные ответы.  
Также в ОС есть файл **hosts**, который предоставляет возможность задать жесткую связь домена и IP адреса. Файл hosts проверяется до обращения к локальному DNS-серверу.
 
 **Внимание:** для электронной почты используется другие DNS-сервера.

## TCP
Протокол IP не может обеспечить надежной доставки данных.  
TCP - протокол надежной доставки данных. Предоставляет протокол, схожий с файловым вводом/выводом.

### Свойства TCP:
* Надежная доставка  
  Если вы получили ответ "данные переданы", это означает что данные доставлены до клиента в том виде, в котором вы их передали (гарантируется проверкой контрольных сумм).  
  Если данные не вышло доставить, то протокол будет предпринимать попытки их доставить.  
  Если протокол "понимает" что данные доставить невозможно, он возвращает код ошибки, что сообщает нам о том, что передача не удалась.  
* Полнодуплексная передача  
  Передача данных в обе стороны.  
* Контроль потока - защита от переполнения буффера  
  При передачи контролируется условие, что передающая сторона передает данных не больше, чем получающая сторона может потребить.

### TCP порты
**TCP порт** - это «адрес» сетевого соединения в пределах одного хоста.  
TCP порты позволяют поддерживать множество открытых соединений на одной машине.  
**Номер порта** - целое неотрицательное число, **не больше 65535** (2 байта).  
***Порты ниже 1024 требуют привилегий суперпользователя для использования*** (актуально для UNIX-систем)  
Одним TCP портом может владеть не более одной программы.
Распределением портов занимается ОС.  

#### Стандартные TCP порты:
* 20,21 - FTP
* 22 - SSH
* 25 - SMTP
* 80 - HTTP
* 443 - HTTPS

#### Установление TCP соединения
При установлении TCP соединения клиент и сервер обмениваются 3 пакетами (*тройное рукопожатие*):

![haskshake](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/tcp.png "Установление TCP соединения")

1. Клиент отправлет сервера пакет с установленным флагом ***SYN*** и **случайным клиентским порядковым номером передачи**.  
   В дальнейшем, этот номер будет использоваться для защиты от подмены пакетов.
2. Сервер открывает ответное соединение и отправляет клиенту пакет с флагами ***SYN***, ***ACK*** и **случайным серверным порядковым номером передачи**.  
3. Клинет отвечает серверу пакетом ***ACK***, подтверждая прием от сервера порядкового номера передачи.

Теперь клиент и сервер имеет пару порядковых номеров передачи и открытое полнодуплексное соединение.  
С этого момента возможна передача данных.

**RTT** (round trim time) - время "путишествия" данных от клиента к серверу и обратно.  
Если клиент и сервер на разных континентах, то RTT может быть более 150 мс.

#### Пример TCP клиента
![tcpclient](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/tcp_client.png "TCP клиент")
Строка: *s.connect(('127.0.0.1', 1234))*- здесь происходит отправка SYN и получение SYN+ACK (может занимать долгое время, равное RTT). После этого сокет стал **клиентским** и готов к работе.  

Сокет может использоват разные протоколы передачи:
* **AF_UNIX** - *передача данных в пределах одной UNIX-машины* (не через протокол IP)
* **AF_TIPC** - передача данных в пределах кластера (не через протокол IP)
* **AF_INET** - передача данных в локальной сети по протоколу IPv4
* **AF_INET6** - передача данных в локальной сети по протоколу IPv6

#### Пример TCP сервера
![tcpserver](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/tcp_server.png "TCP сервер")
Строка: *s.bind(('127.0.0.1', 1234))* - занимаем порт в ОС  
Строка: *s.listen(10)* - задает максимальный размер очереди ожидающих обработки подключений по данному endpoint, остальным протокол TCP откажет в соединии.  
После этого сокет стал **серверным** и готов к работе.

Строка: *conn, addr = s.accept()* - блокирует поток программы до момента соединения с клиентом, т.е. до мемента приема от клиента SYN, отправки клиенту SYN+ACK и получения от клиента ACK. После получения от клиента пакета с флагом ACK поток программы разблокируется и метод *s.accept()* возвращает кортеж: соединение с клиентом + адрес клиента  

#### Нюансы передачи по TCP
При чтении сокета никто не гарантирует что в нем окажеться столько данных, сколько мы ожидаем.  
Например, клиент успел передать только 10 байт, а не весь ожидаемый объем 9из-за обрыва или высокой нагрузки).  
*Одним пакетом обысно отправляются данные до 8КБ*
При чтении из сети желательно следить какую часть данных мы уже прочитали, и сколько нам осталось вычитать.
Например передаем 550 килобайт:
1. Считываем 200 байт
2. Считываем 200 байт
3. Считываем 150 байт

**Правильное вычитывание данных из сокета**
![correctreceiving](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/tcp_server.png "Правильное вычитывание данных из сокета")

**Правильная запись данных в сокет**
![correctsending](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/correct_tcp_sending.png "Правильная запись данных в сокет")

### BEST PRACTICES (по отправке и вычитыванию данных из сокета)
* При отправке необходимо разбивать большие пакеты на небольные части и отправлять последовательно, пока покет не будет отправлен полностью.  
* При получении неообходимо знать ожидаемую длину данных, вычитывать их небольшими частями из сокета, накапливать в буффере, по окончанию вычитывания считать "остатки" расчитав ожидаемый размер оставшейся части по кол-ву принятых байт и ожидаемой длине пакета.  

**Поэтому при реализации прикладных протоколов связи необходимо в начале пакета передавать его длину.**

["Доступно о сокетах в Python"](https://github.com/ilmen/tp-stepic/blob/master/synopses/1.6.Network.PythonSocketsForDummies.pdf)

## TLS
**TLS - ранее использовалось название SSL**  
**TLS** (*Transport Layer Security*) - криптографический протокол, обеспечивающий безопасную передачу данных между хостами в Internet.

* Аутентификация сервера (и клиента)  
  Защита от подмены hosts и т.п. угроз
* Шифрование и сжатие передаваемой информации  
  Защита от перехвата критических данных
* Защита от подмены и проверка целостности сообщений
 
### Установка TLS соединения
![tls-connection](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/tls.png "Схема установки TLS соединения")

* ClientHello - клиент указывает желаемые опции соединения  
  В сообщении **clientHello** передаются опции соединения, которые клиент (браузер) хотел бы использовать:
  * наличие шифрование
  * наличие сжатие
  * вид шифрования
* ServerHello - сервер подтверждает опции соединения
* Certificate - сервер посылает клиенту свой сертификат  
  Что из себя представляет TLS сертификат:
  * Содержит в себе публичный ключ для ассиметричного
  * Подписан другим сертификатом, который подписан сертификационным сервером.
    * По этим данным можно аутентифицировать сервер, передав его на проверку сертификационному серверу.
* Клиент проверяет сертификат.  
  На данном этапе соединение может быть отклонено
* ClientKeyExchange - клиент отправляет серверу ключ симметричного шифрования (или параметры для его генерации)  
  После этого идет установка симметричного шифрования:
  * либо передав ключ *в явном виде на сервер*
  * либо использовав спец. алгоритм для генерации одинаковых ключей на клиенте и сервере *без явной пересылки ключа*.
• Finished - сервер подтверждает завершение рукопожатия

Соединение TLS считается открытым. Можно переходить к передачи данных.

#### Недостатки TLS
Установление TCP и TLS соединения требует существенного времени.  
**Минимум 1 RTT для TCP соединения и 2 RTT для TLS соединения, плюс время на проверку сертификата сервера**.

Поэтому, если для каждого HTTPs запроса открывать новое соединение, то это очень сильно повлияет на производительность сайта.
