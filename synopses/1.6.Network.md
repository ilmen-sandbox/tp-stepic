# Что происходит при HTTP запросе?

1. Браузер парсит URL (примем его за абсолютный для простоты), извлекаем имя хоста (домен), протокол (http, https)
2. Используя DNS преобразуем имя хоста (домен) в IP-адрес web-сервера
3. Устанавливаем TCP соединение с web-сервером
  1. Если используется HTTPs - устанавливаем TLS соединение (шифрованное и защищенное) поверх TCP
4. Формируем HTTP-запрос, отправляем его web-серверу, получаем документ-ответ
5. Пусть браузер закрывает соединение **(это для HTTP/1.0)**
6. Браузер загружает связанные ресурсы
  
## Стек сетевых протоколов
*Указаны не все уровни стека*
![stack](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/stack.png "стек сетевых протоколов")

* HTTPs+TLS: реализовано в userspace (браузер/web-сервер)
* TCP+IP: реализовано в ОС клиента/сервера

Запрос от браузера проходит по всем уровням стека на клиенской машине, передаются на сервер, на стороне сервера сообщение "поднимаются" по стеку вверх.

Т.е. передача по HTTP(s) - это передача сообщения на самом нижнем уровне, по с включением в стек уровней TLS и HTTP(s) (TLS использутся только при использовании HTTPs).

## DNS
**DNS** (Domain Name System) - это *распределенная база данных*, хранящая информацию о доменах, в первую очередь отображение доменных имен на IP адреса машин, обслуживающих эти домены.

### Пространство доменных имен
**Пространство доменных имен** - строки, состоящие из слов, разделенных точками. Домены образуют древовидную структуру.

Например, сайт *wikipedia* имеет домен: ru.wikipedia.org.  
0. Домен нулевого уровня: .  
*Обычно не указывается в URL*  
1. Домены первого уровня: ru, en, org, edu, ...  
*Практически статичное множество (например* ***ru*** *- Россия,* ***org*** *- организации,* ***edu*** *- образование)*  
2. Домены второго уровня: yandex, stepic, mail, wikipedia, ...  
*Примерно соответствуют организациям*  
3. Домены третьего уровня и т.д.

### Зоны
База DNS поделена на зоны. Каждая зона находиться под единым *административным* контролем (обслуживается *одной организацией*).  
В одну зону могут входить и домены одного уровня, так и некоторая иерархия доменов.  
Управление более высокоуровневыми или низкоуровневыми зонами может быть делегировано другим организациям.

![dns-zones](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/zones.png "Зоны DNS")  

### DNS запрос
DNS запросы производятся по специальному протоколу.  
На любом компьютере всегда **должен** быть прописан адрес DNS сервера (обычно, DNS-сервер организации или DNS-сервер провайдера).  
* Может быть задан вручную в настройках сетевого соединения
* Может быть получен по протоколу DHCP от роутера или провайдера
* Существует заранее известный список **корневых** DNS-серверов (те самые *ru*, *org* и т.п., их IP меняется очень редко и может быть закешировано на долго в недрах ОС)

Вот как происходит обработка запроса:
![dns-request](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/dnsreq.png "DNS запрос")  
Для **снижения нагрузки** на DNS-сервера (*особенно нагрузки на корневые DNS-сервера*) используется механизм **кеширования** ответов DNS-серверов на DNS-сервере провайдера, чтобы при последующих запросах не делегировать запросы к сторонним DNS-серверам, а сразу возвращать закешированные ответы.  
Также в ОС есть файл **hosts**, который предоставляет возможность задать жесткую связь домена и IP адреса. Файл hosts проверяется до обращения к локальному DNS-серверу.
 
 **Внимание:** для электронной почты используется другие DNS-сервера.

## TCP
Протокол IP не может обеспечить надежной доставки данных.  
TCP - протокол надежной доставки данных. Предоставляет протокол, схожий с файловым вводом/выводом.

### Свойства TCP:
* Надежная доставка  
  Если вы получили ответ "данные переданы", это означает что данные доставлены до клиента в том виде, в котором вы их передали (гарантируется проверкой контрольных сумм).  
  Если данные не вышло доставить, то протокол будет предпринимать попытки их доставить.  
  Если протокол "понимает" что данные доставить невозможно, он возвращает код ошибки, что сообщает нам о том, что передача не удалась.  
* Полнодуплексная передача  
  Передача данных в обе стороны.  
* Контроль потока - защита от переполнения буффера  
  При передачи контролируется условие, что передающая сторона передает данных не больше, чем получающая сторона может потребить.

### TCP порты
**TCP порт** - это «адрес» сетевого соединения в пределах одного хоста.  
TCP порты позволяют поддерживать множество открытых соединений на одной машине.  
**Номер порта** - целое неотрицательное число, **не больше 65535** (2 байта).  
***Порты ниже 1024 требуют привилегий суперпользователя для использования*** (актуально для UNIX-систем)  
Одним TCP портом может владеть не более одной программы.
Распределением портов занимается ОС.  

#### Стандартные TCP порты:
* 20,21 - FTP
* 22 - SSH
* 25 - SMTP
* 80 - HTTP
* 443 - HTTPS

#### Установление TCP соединения
При установлении TCP соединения клиент и сервер обмениваются 3 пакетами (*тройное рукопожатие*):

![haskshake](https://github.com/ilmen/tp-stepic/blob/master/lesson-5/pictures/tcp.png "Установление TCP соединения")

1. Клиент отправлет сервера пакет с установленным флагом ***SYN*** и **случайным клиентским порядковым номером передачи**.  
   В дальнейшем, этот номер будет использоваться для защиты от подмены пакетов.
2. Сервер открывает ответное соединение и отправляет клиенту пакет с флагами ***SYN***, ***ACK*** и **случайным серверным порядковым номером передачи**.  
3. Клинет отвечает серверу пакетом ***ACK***, подтверждая прием от сервера порядкового номера передачи.

Теперь клиент и сервер имеет пару порядковых номеров передачи и открытое полнодуплексное соединение.  
С этого момента возможна передача данных.

**RTT** (round trim time) - время "путишествия" данных от клиента к серверу и обратно.  
Если клиент и сервер на разных континентах, то RTT может быть более 150 мс.

#### Пример TCP клиента  
import socket  
req = "Hello tcp!"  
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
s.connect(('127.0.0.1', 1234))    # здесь происходит отправка SYN и получение SYN+ACK (может занимать долгое время, равное RTT)  
# теперь сокет стал **клиентским**  
s.send(req)  
rsp = s.recv(1024)  
s.close()  

Сокет может использоват разные протоколы передачи:
* **AF_UNIX** - *передача данных в пределах одной UNIX-машины* (не через протокол IP)
* **AF_TIPC** - передача данных в пределах кластера (не через протокол IP)
* **AF_INET** - передача данных в локальной сети по протоколу IPv4
* **AF_INET6** - передача данных в локальной сети по протоколу IPv6

#### Пример TCP сервера
import socket  
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  
s.bind(('127.0.0.1', 1234)) # занимаем порт в ОС  
s.listen(10)                # максимальный размер очереди ожидающиз обработки подключений по данному endpoint, остальным протокол TCP откажет в соединии  
# теперь сокет стал **сервераным**  
while True:  
__conn, addr = s.accept()   # поток программы блокируется до момента соединения с клиентом,  
____________________________# т.е. до мемента приема от клиента SYN, отправки клиенту SYN+ACK и получения от клиента ACK  
____________________________# после получения от клиента пакета с флагом ACK поток программы разблокируется  
____________________________# и метод s.accept() возвращает кортеж: соединение с клиентом + адрес клиента  
__while True:  
____data = conn.recv(1024)  # получаем данные из сокета по 1024 байт  
____if not data: break  
____conn.send(data)  
__conn.close()  

#### Нюансы передачи по TCP
При чтении сокета никто не гарантирует что в нем окажеться столько данных, сколько мы ожидаем.  
Например, клиент успел передать только 10 байт, а не весь ожидаемый объем 9из-за обрыва или высокой нагрузки).  
*Одним пакетом обысно отправляются данные до 8КБ*
При чтении из сети желательно следить какую часть данных мы уже прочитали, и сколько нам осталось вычитать.
Например передаем 550 килобайт:
1. Считываем 200 байт
2. Считываем 200 байт
3. Считываем 150 байт

**Правильное вычитывание данных из сокета**
def myreceive(sock, msglen):
__msg = ''
__while len(msg) < msglen:
____chunk = sock.recv(msglen-len(msg))
____if chunk == '':
______raise RuntimeError("broken")
____msg = msg + chunk
__return msg

**Правильная запись данных в сокет**
def mysend(sock, msg):
__totalsent = 0
__while totalsent < len(msg):
____sent = sock.send(msg[totalsent:])
____if sent == 0:
______raise RuntimeError("broken")
____totalsent = totalsent + sent

### BEST PRACTICES (по отправке и вычитыванию данных из сокета)
* При отправке необходимо разбивать большие пакеты на небольные части и отправлять последовательно, пока покет не будет отправлен полностью.  
* При получении неообходимо знать ожидаемую длину данных, вычитывать их небольшими частями из сокета, накапливать в буффере, по окончанию вычитывания считать "остатки" расчитав ожидаемый размер оставшейся части по кол-ву принятых байт и ожидаемой длине пакета.  

**Поэтому при реализации прикладных протоколов связи необходимо в начале пакета передавать его длину.**
