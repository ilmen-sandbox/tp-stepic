# Frontend и Backend сервера (не UI)

## Виды обрабатываемых запросов
* Статические файлы
* Динамические страницы
* API сайта
* Персистентные соединения
* AJAX запросы

## Архитектура **"Frontend и Backend"**
**Web-сервер (frontend)** обрабатывает только запросы на получение ***статических файлов***   
**App-сервер (backend)** обрабатывает остальные типы запросов

![frontend_backend_architecture](https://github.com/ilmen/tp-stepic/blob/master/lesson-8/pictures/front_back.png "Архитектура серверов Frontend и Backend")
* Все клиенты подключаются к frontend серверу
* frontend сервер - легковестный web-сервера с мультиплексированием (например, NGinx)
* frontend сервер занимается проксированием запросов backend-серверам и другими "административными" задачами
* Backend сервер занимается ТОЛЬКО бизнез задачами
* Backend сервер работает минимально возможное время (за счет механизма reverse proxy)
* Backend сервер максимально быстро отдает ответ frontend серверу

Процедура передачи запроса от frontend к backend называет **проксирование**.

## Задачи Frontend (web) сервера
* отдача статических документов
* проксирование (reverse proxy)
* *балансировка нагрузки*
* кеширование ответов backend
* *сборка SSI* (frontend сервер делает запрос за основной страницей и за дополнительными к backend, потом собирает результирующую страницу и возвращает его клиенту одной посылкой - ***aka yandex***)
* авторизация, SSL, нарезка картинок, gzip
* ***персистентные соединения*** (websocket'ы, long-polling запросы и т.п.)

Использование архитектуры "frontend backend" позволяет упростить backend-сервера, сконцентрирован их код на бизнес-логике, предоставив выполнение "административных задач" frontend-серверу.

## Reverse proxy
* frontend (медленно) читает запрос от клиента
* frontend (быстро) передает запрос свободному backend (например, 5 мс)
* backend генерирует страницу (например, 250 мс)
* backend (быстро) возвращает ответ fronten серверу (например, 5 мс)
* frontend (медленно) возвращает ответ клиенту (например, закешировав ответ backend сервера на диск и раздавая его с максимально доступной скоростью)

**Результат:** backend занят минимально возможное время. Решается проблема работы с "медленными клиентами".

# Настройка проксирования в NGINX
![nginx_proxy](https://github.com/ilmen/tp-stepic/blob/master/lesson-8/pictures/nginx_proxy.png "Настройка проксирования в NGINX")

Директива **proxy_pass** означает что запрос нужно передать на указанный URL или в UpStream (*http://backend* - это UpStream, см. далее).  
Директива работает подобно root, только после формирования нового URL сервер не ищет файл на диске, а инициирует запрос на полученный URL (*frontend сервер становится web-клиентом*).  
Директева **proxy_set_header** позволяет задавать дополнительные (и перезаписывать существующие) заголовки проксируемого запроса.  
Например, использование директивы **proxy_set_header Host $proxy_host;** позволяет задать правильное значение заголовка Host.  
> Если backend-сервер и frontend-сервер находятся в разных доменах (второй location на изображении), то backend не сможет обработать спроксированный запрос, т.к. без подмены заголовка Host будет содержать адрес frontend-сервера, для которого могут отсутствовать подходящие сексии конфигурации (нет virtual host) на backend-сервере.

* **proxy_set_header Host $proxy_host;** - меняет значение заголовка Host на адрес backend-сервера
* **proxy_set_header Host $host;** - сохраняет исходное значение заголовка Host (адрес frontend-сервера)

> При проксировании запросов теряется IP-адрес соединения с сервером (его знает только frontend и, по умолчанию, он этим знанием никак не делиться с backend).

Директива **proxy_set_header X-Real-IP $remote_addr;** позволяет задать заголовок **X-Real-IP** с реальным IP-адресом клиента и передать запрос с этим заголовком с frontend на backend.

Так же, в NGINX можно задавать timeout для проксируемого запроса и т.п..

## Настройка upstream в NGINX
![nginx_upstream](https://github.com/ilmen/tp-stepic/blob/master/lesson-8/pictures/nginx_upstream.png "Настройка upstream в NGINX")

**UpStream (или ферма)** - группа серверов, работающих под общим именем (в NGINX).
* Можно использовать IP, UNIX_SOXKET или URL в качестве адреса сервера
* У сервером можно указывать разные порты

### Директивы серверов в UpStream:
* **weigth** - "вес" сервера, натуральное число (балансировка)
* **max_fails** - кол-во ошибок по таймаутут (сервер не ответил), до исключения (временного) сервера из списка активных серверов (балансировка)
* **backup** - резервный сервер, используемый только когда все остальные (не backup) сервер не отвечают

Часто в проекте все backend-сервера объединяют в один UpStream (в одну ферму) или разбивают сервера на логическую структуру:
* UI-сервера
* API-сервера
* Сервера для обработки запрос с мобильных приложений

# Application сервера (backend сервера)
Роль application сервера заключается в исполнении бизнес-логики приложения и генерации динамических документов.  
На каждый HTTP запрос application сервер запускает некоторый обработчик в приложении. Это может быть функция, класс или программа, в зависимости от технологии (т.е. занимается преобразование HTTP запроса клиента в вызов обработчика на сервере).

## Протоколы запуска приложения на сервере:
* Servlets и др. специализированные API  
  Java-классы, вызываемые HTTP сервером, написанном на Java.
* mod_perl, mod_python, mod_php  
  Плагины под разные ЯП для Apache.  
  Дают слишком много возможностей для web-приложений, сложный в исполнении, все реже используются.
* CGI  
  Один из самых первых.  
  Позволяет web-приложение представить в виде исполняемого приложения и передает туда аргументы командной строки.  
  В чистом виде сейчас практически не используется. Стал прообразом для множества дочерных протоколов.
* FastCGI, SCGI  
  Наследники CGI.
* PSGI (Perl), WSGI (Python), Rack (Ruby)  
  Современные вендорские протоколы.

## CGI
**CGI - Common Gateway Interface**
Пусть есть web-сервер умеет отдавать файлы с диска, тогда для создания динамических страниц можно по запросу вызвать программу и вернуть клиенту результат работы программы (запрос передает по StdIn, HTTP документ получается из StdOut программы, текст из StdError записывается в лог ошибок HTTP сервер).

### Соглашения CGI:
* Метод, QueryString, заголовки запроса - через **переменные окружения**
* Тело запроса передается через **STDIN**
* Заголовки и тело ответа возвращаются через **STDOUT**
* HTTP код ответа передается через псевдозаголовок **Status**
* Поток ошибок **STDERR** направляется в лог ошибок сервера

### Схема работы CGI
![cgi](https://github.com/ilmen/tp-stepic/blob/master/lesson-8/pictures/cgi.png "Схема работы протокола CGI")

### Недостатки CGI
Основной недостаток CGI - это **задержки на запуск**.  
  Между началом обработки и передачей параметров запущенной программе может пройти долгое время, т.е. приходиться ожидать задержки на считывание испольняемого файла, задерки на работу интерпретатора (в случае скриптовых языков), задержки на загрузку программы и установление всех необходимых соединений (например, соединение с БД), задержки на считывание конфигурации.  
  Т.е. на каждый HTTP запрос приходять один запуск программы со всей его медленностью.
  
### Переменные окружения
* **REQUEST_METHOD** - метод запроса
* **PATH_INFO** - путь из URL (без домена)
* **QUERY_STRING** - фрагмент URL после **?** (параметры **GET** запроса)
* **REMOTE_ADDR** - IP адрес пользователя
* **CONTENT_LENGTH** - длина тела запроса
* **HTTP_COOKIE** - заголовок **Cookie**
* **HTTP_MYHEADER** - HTTP заголовок **MyHeader**

**Все HTTP заголовки становяться переменными окружения** (с именем "HTTP_" + имя заголовка в верхнем регистре).

## FastCGI и SCGI
Основная проблема CGI - низкая производительность.

Протоколы FastCGI и SCGI призваны решить эту проблему путем демонизации приложения. Иногда это возможно сделать даже без изменения кода CGI приложения.

### Схема работы FastCGI и SCGI
![fastcgi_scgi](https://github.com/ilmen/tp-stepic/blob/master/lesson-8/pictures/fastcgi.png "Схема работы протоколов FastCGI и SCGI")

Протоколы FastCGI и SCGI бинарные, это ускоряет парсинг.  
Application сервер взаимодействует с web-приложением через сокет.  
Сокет вызывает функцию.  
Можно позменить StdIN и StdOUT с помошщью сокетов и получить с стандартного CGI приложение готовое FastCGI, с большей производительностью.

## WSGI
WSGI - Web Server Gateway Interface  
*Актуальный протокол*  
Протокол WSGI используется в Python.  
**WSGI, PSGI, Rack** - протоколы вызова функции обработчика из application сервера.  
Сам application server при этом может выполняться в отдельном процессе или совпадать с web сервером.  
Как правило, при использовании этих протоколов в качестве application сервера выступает отдельный легковесный процесс.  

### WSGI обработчик
![wsgi_handler](https://github.com/ilmen/tp-stepic/blob/master/lesson-8/pictures/wsgi-handler.png "WSGI обработчик")

* **первый параметр функции** (обычно **environ**) - словарь (dict) со всеми переменными окружения (имена переменных из CGI)
* **второй параметр функции** (обычно **start_response**) - делегат для отправки результатов клиенту (доступна суперпозиция функций в Python)

Функция возвращает тело ответа как итеррируемую величину (из-за возможных размеров тела ответа).  
в простейшем случае достаточно ** return [ body ];**

### Особенности WSGI
* Обработчик - функция или класс (**callable**)
* Метод, QueryString, заголовки запроса - через аргумент **environ**
* Тело запроса передается через file-handle **wsgi.input**
* HTTP код ответа и заголовки ответа передаются через вызов функции **start_response**
* Тело ответа возвращается в виде списка (**iterable**) из обработчика
* Поток ошибок должен быть направлен в file-handle **wsgi.stderr**

### Переменные environ
* CGI-like переменные: **REQUEST_URI** , ...
* **wsgi.version** - версия WSGI протокола
* **wsgi.url_scheme** - схема текущего URL: https или http
* **wsgi.input** - file-handle для чтения тела запроса
* **wsgi.errors** - file-handle для вывода ошибок
* **wsgi.multithreaded** - используется, когда приложение вызывает внутри boostrap-сервера (для аккуратной работы с общей памятья)
* **wsgi.multiprocess** - используется, когда приложение работает в prefork режиме

### Схема работы WSGI
![wsgi](https://github.com/ilmen/tp-stepic/blob/master/lesson-8/pictures/wsgi.png "Схема работы протокола WSGI")

Связь frontend и backend серверов осуществляется через **HTTP** или через бинарный протокол **UMSGI** (что несколько ускоряет работу).

### Задачи web-приложения
* Анализ **PATH_INFO** и выбор конкретного обработчика (**URL routing**)
* Разбор конкретных заголовков, например **Cookie**
* Разбор **QUERY_STRING**
* Разбор тела запроса:
  * *x-www-form-urlencoded*
  * *multipart/form-data*
*Вывод правильных заголовков ответа
