# Frontend и Backend сервера (не UI)

## Виды обрабатываемых запросов
* Статические файлы
* Динамические страницы
* API сайта
* Персистентные соединения
* AJAX запросы

## Архитектура **"Frontend и Backend"**
**Web-сервер (frontend)** обрабатывает только запросы на получение ***статических файлов***   
**App-сервер (backend)** обрабатывает остальные типы запросов

![frontend_backend_architecture](https://github.com/ilmen/tp-stepic/blob/master/lesson-8/pictures/front_back.png "Архитектура серверов Frontend и Backend")
* Все клиенты подключаются к frontend серверу
* frontend сервер - легковестный web-сервера с мультиплексированием (например, NGinx)
* frontend сервер занимается проксированием запросов backend-серверам и другими "административными" задачами
* Backend сервер занимается ТОЛЬКО бизнез задачами
* Backend сервер работает минимально возможное время (за счет механизма reverse proxy)
* Backend сервер максимально быстро отдает ответ frontend серверу

Процедура передачи запроса от frontend к backend называет **проксирование**.

## Задачи Frontend (web) сервера
* отдача статических документов
* проксирование (reverse proxy)
* *балансировка нагрузки*
* кеширование ответов backend
* *сборка SSI* (frontend сервер делает запрос за основной страницей и за дополнительными к backend, потом собирает результирующую страницу и возвращает его клиенту одной посылкой - ***aka yandex***)
* авторизация, SSL, нарезка картинок, gzip

Использование архитектуры "frontend backend" позволяет упростить backend-сервера, сконцентрирован их код на бизнес-логике, предоставив выполнение "административных задач" frontend-серверу.

## Reverse proxy
* frontend (медленно) читает запрос от клиента
* frontend (быстро) передает запрос свободному backend (например, 5 мс)
* backend генерирует страницу (например, 250 мс)
* backend (быстро) возвращает ответ fronten серверу (например, 5 мс)
* frontend (медленно) возвращает ответ клиенту (например, закешировав ответ backend сервера на диск и раздавая его с максимально доступной скоростью)

**Результат:** backend занят минимально возможное время. Решается проблема работы с "медленными клиентами".

# Настройка проксирования в NGINX
![nginx_proxy](https://github.com/ilmen/tp-stepic/blob/master/lesson-8/pictures/nginx_proxy.png "Настройка проксирования в NGINX")

Директива **proxy_pass** означает что запрос нужно передать на указанный URL или в UpStream (*http://backend* - это UpStream, см. далее).  
Директива работает подобно root, только после формирования нового URL сервер не ищет файл на диске, а инициирует запрос на полученный URL (*frontend сервер становится web-клиентом*).  
Директева **proxy_set_header** позволяет задавать дополнительные (и перезаписывать существующие) заголовки проксируемого запроса.  
Например, использование директивы **proxy_set_header Host $proxy_host;** позволяет задать правильное значение заголовка Host.  
Если backend-сервер и frontend-сервер находятся в разных доменах (второй location на изображении), то backend не сможет обработать спроксированный запрос, т.к. без подмены заголовка Host будет содержать адрес frontend-сервера, для которого могут отсутствовать подходящие сексии конфигурации (нет virtual host) на backend-сервере.  
* **proxy_set_header Host $proxy_host;** - меняет значение заголовка Host на адрес backend-сервера
* **proxy_set_header Host $host;** - сохраняет исходное значение заголовка Host (адрес frontend-сервера)

# Настройка upstream в NGINX
![nginx_upstream](https://github.com/ilmen/tp-stepic/blob/master/lesson-8/pictures/nginx_upstream.png "Настройка upstream в NGINX")
