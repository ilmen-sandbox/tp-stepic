# Web-сервера

## Конфигурация web сервера

### Терминология
**virtual host, вирт. хост** - секция конфига web сервера, отвечающая за обслуживание определенного домена
**location** - секция конфига, отвечающая за обслуживание определенной группы URL

### Секции и директивы
* http ― конфигурация для HTTP сервера
* server ― конфигурация домена (вирт. Хоста)
* server_name ― имена доменов
* location ― локейшен, группа URL
* root , alias ― откуда нужно брать файлы
* error_log ― лог ошибок сервера
* access_log ― лог запросов

### Приоритеты location в nginx
1. location = /img/1.jpg
2. location ^~ /pic/
3. location ~* \.jpg$
4. location /img/

*При одинаковом приоритете используется тот location, что находится выше в конфиге*

### Root и alias
> location ~\* ^.+\.(jpg|jpeg|gif|png)$ {  
>   root /www/images;  
> }  
>   location /sitemap/ {  
>   alias /home/www/generated/;  
> }

**/2015/10/ae2b5.png** → **/www/images/2015/10/ae2b5.png**  
**/sitemap/index.xml** → **/home/www/generated/index.xml**

### Проверка доступа
Для того, чтобы открыть файл, необходимо иметь права на чтение ***r*** самого файла и на исполнение ***x*** директорий, в которых он находится. Наличие прав проверяется следующим образом:
* Если совпадает пользователь *-****rw-****r--r--*
* Если совпадает группа *-rw-****r--****r--*
* Иначе *-rw-r--****r--***

## Параллелизация обработки запросов
В Python существует несколько моделей асинхронного программирования:
* использование потоков - multithreading
* использование процессов - prefork, pool of workers
* использование мультиплексирования

В синхронном коде (и в синхронных частях многопоточных/многопроцессовых программ) при обращении к сокету за данными (s.recv) python обращается к ОС за поучением данных из порта. Здесь есть два варианта:
1. система сразу вернет данные, т.к. они уже получены
2. система вернет сигнал **EAGAIN/E_WOULDBLOCK** и переведет приложение в режим сна до момента получения данных в сокете

### Prefork
*Аналог в .NET не найден (?)*
В код программы добавляется директива **fork()**  
Когда программа доходит до нее, то создается новый процесс и весь последующий код метода выполняется в отдельном процессе,
а основной процесс продолжает работу возвратившись по стеку вверх (до того места, где был вызван метод (?).

#### Плюсы и минусы
➕ простота разработки   
➕ можно использовать любые библиотеки   
➖ большое потребление памяти: 1 клиент = 1 процесс  
➖ проблема с долгоживущими соединениями

### Multithreading
*Классическая многопоточность с обратными вызовами*
#### Плюсы и минусы
*по сравнению с prefork*  
➕ экономия памяти: 1 клиент = 1 поток   
➖ требует аккуратной работы с памятью (т.к. она разделяемый ресурс)  
➖ как следствие, накладывает ограничение на выбор библиотек  

### Мультиплексирование
*Аналог async/await в .NET* - event-driven обработка с моделью *последовательное исполнение* → *события*  
Мы создаем пул сокетов, и раз за разом запрашиваем список готовых к получению/передачи сокетов. Система не блокирует программу, а лишь возвращает список подходящих сокетов (python сам формирует список сокетов, наблюдая за кодами ответа ОС на запрос данных из интересующих сокетов, если ОС вернула **EAGAIN/E_WOULDBLOCK**, значит этот сокет не включается в список доступных для IO-операций).

#### Плюсы и минусы
➕ быстро, программа не блокируется   
➕ экономия памяти: 1 клиент = 1 объект (1 структура)   
➕ обработка большого количества клиентов    
➕ обработка медленных или долгоживущих соединений   
➖ тяжело программировать   
➖ использование блокирующих вызовов все портит

## Кто есть кто
* **Apache** – prefork, worker, threads (язык С)  
  быстрый, отлично подходит для статики
* **Tomcat, Jetty** – threads (язык Java)  
  средние по скорости, неподходит для статики
* **Starman** – prefork (язык Perl)  
  медленный, но удобный для интерграции с Perl
* **Gunicorn** – prefork (язык python)  
  медленный, но удобный для интерграции с Python
* **Nginx, Lighttpd** – асинхронные (язык С)  
  быстрый, поддерживает большое кол-во соединений, подходит для долгих соединений
* **Node.JS, Tornado** – асинхронные (языки высокого уровня)  
  поддерживают большое кол-во соединений, гибкие, легко расшираемые, подходят для долгих соединений
