# Web-сервера

## Конфигурация web сервера

### Терминология
**virtual host, вирт. хост** - секция конфига web сервера, отвечающая за обслуживание определенного домена
**location** - секция конфига, отвечающая за обслуживание определенной группы URL

### Секции и директивы
* http ― конфигурация для HTTP сервера
* server ― конфигурация домена (вирт. Хоста)
* server_name ― имена доменов
* location ― локейшен, группа URL
* root , alias ― откуда нужно брать файлы
* error_log ― лог ошибок сервера
* access_log ― лог запросов

### Приоритеты location в nginx
* location = /img/1.jpg
* location ^~ /pic/
* location ~* \.jpg$
* location /img/

*При одинаковом приоритете используется тот location, что находится выше в конфиге*

### Root и alias
> location ~\* ^.+\.(jpg|jpeg|gif|png)$ {  
>   root /www/images;  
> }  
>   location /sitemap/ {  
>   alias /home/www/generated/;  
> }

**/2015/10/ae2b5.png** → **/www/images/2015/10/ae2b5.png**  
**/sitemap/index.xml** → **/home/www/generated/index.xml**

### Проверка доступа
Для того, чтобы открыть файл, необходимо иметь права на чтение ***r*** самого файла и на исполнение ***x*** директорий, в которых он находится. Наличие прав проверяется следующим образом:
* Если совпадает пользователь *-****rw-****r--r--*
* Если совпадает группа *-rw-****r--****r--*
* Иначе *-rw-r--****r--***

## Параллелизация обработки запросов
В Python существует несколько моделей асинхронного программирования:
* использование потоков - multithreading
* использование процессов - prefork, pool of workers
* использование мультиплексирования

В синхронном коде (и в синхронных частях многопоточных/многопроцессовых программ) при обращении к сокету за данными (s.recv) python обращается к ОС за поучением данных из порта. Здесь есть два варианта:
1. система сразу вернет данные, т.к. они уже получены
2. система вернет сигнал **EAGAIN/E_WOULDBLOCK** и переведет приложение в режим сна до момента получения данных в сокете

### Prefork
В код программы добавляется директива **fork()**  
Когда программа доходит до нее, то создается новый процесс и весь последующий код метода выполняется в отдельном процессе,
а основной процесс продолжает работу возвратившись по стеку вверх (до того места, где был вызван метод (?).

#### Плюсы и минусы
➕ простота разработки   
➕ можно использовать любые библиотеки   
➖ большое потребление памяти: 1 клиент = 1 процесс  
➖ проблема с долгоживущими соединениями

### Multithreading
Классическая многопоточность с обратными вызовами
#### Плюсы и минусы
*по сравнению с prefork*  
➕ экономия памяти: 1 клиент = 1 поток   
➖ требует аккуратной работы с памятью (т.к. она разделяемый ресурс)  
➖ как следствие, накладывает ограничение на выбор библиотек  

### Мультиплексирование
*Аналог async/await в .NET*  
Мы создаем пул сокетов, и раз за разом запрашиваем список готовых к получению/передачи сокетов. Система не блокирует программу, а лишь возвращает список подходящих сокетов (python сам формирует список сокетов, наблюдая за кодами ответа ОС на запрос данных из интересующих сокетов, если ОС вернула **EAGAIN/E_WOULDBLOCK**, значит этот сокет не включается в список доступных для IO-операций).
