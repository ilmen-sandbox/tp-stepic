# Протокол HTTP

## HTTP
**HTTP** специально предназначен для передачи гипертекстовых документов.

### Назначение HTTP
Существует множество задач, которые не решены в протоколе TCP и должны быть решены выше по стеку.

* Передача документов  
  Данные в TCP представляют из себя поток байт, HTTP задают внутренную структуру передаваемый данных (документы).
* Передача мета-информации  
  HTTP позволяет передавать мета-информацию о документе, например, MIME-тип, длину документа (для удобного вычитывания из сокета).
* Авторизация пользователя
* Поддержка сессий  
  Протокол HTTP работает по принципу "запрос-ответ", и не предпологает постоянное соединение (каждый новый документ может обрабатываться разными серверами).  
  Поэтому HTTP позволяет хранить данные о пользователях (сессии) между подключениями
* Кеширование документов  
  Используется для уменьшения нагрузки на сервера.
* Согласование содержимого (negotiation)  
  Позволяет клиенту и серверу согласовать опции: использование GZip или передавать документы только на французком языке
* Управление соединением
  HTTP позволяет гибко управлять соединением (закрыть после запроса или оставить открытым для последующих запросов)
  
### HTTP-запрос
![httprequest](https://github.com/ilmen/tp-stepic/blob/master/lesson-6/pictures/netflow.png "Схема HTTP запроса")

### Ключевые особенности HTTP
* Работает поверх TCP/TLS
* Протокол запрос-ответ
* По-умолчанию не используется HTTP **stateless**  
  Изначально HTTP расчитывался как stateless протокол, где соединение после запроса закрывается и сервер не хранит никаких записей про клиента (*ответ сервера формируется только исходя из данных запроса*).  
  HTTP позволяет передавать информацию о клиенте с помощью заголовков.  
  При этом **нет гарантии**, что один клиент будет всегда работать только с одним сервером.  
  **В таких условиях может существовать только stateless архитектура.**  
  (Но HTTP поддерживает механизм сессий, что делает его statefull протоколом, но т.к. использование сессий опционально и сессии не явлюятся критической опцией HTTP, можно пренебречь ими и считать HTTP stateless протоколом) 
* **Текстовый** протокол
* Расширяемый протокол  
  Следствие применения текстового протокола.  
  В протоколе HTTP различные опции передачи задаются заголовками.  
  Есть **стандартный набор заголовков**, поддерживаемых большинством браузеров.  
  Но **можно расширить протокол HTTP, используя свои собственные заголовки**.

## HTTP-запросы
### HTTP/1.0 запрос
GET http://www.ru/robots.txt HTTP/1.0 
Accept: text/html, text/plain  
User-Agent: telnet/hands  
If-Modified-Since: Fri, 24 Jul 2015 22:53:05 GMT

Перевод строки (по стандарту) **\r\n**  
Некоторые сервера понимают нестандартный перенос **\n**

* Первая строка: строка запроса  
  *GET http://www.ru/robots.txt HTTP/1.0*
  * GET - метод запроса
  * http://www.ru/robots.txt - URL документа  
    **В HTTP/1.0 поддерживаются только абсолютные пути (по стандарту ?)**
  * HTTP/1.0 - версия протокола
* Последующие строки - заголовка, по одному на строку
  * Заголовки состоят из имени и значения, разделенных символом **:**
  * Залоговки могут содержать в себе буквы, цифры, тире, слеш (все ?)
  * Имена заголовков **не могут содержать пробелов**
  * **Заголовки не должны содержать перевода строки**
* **Пустая строка сигнализирует об окончании заголовков**
* После пустой строки может идти тело запроса (если оно предусматривается данным типом запроса)

### HTTP/1.1 запрос
GET /robots.txt HTTP/1.1  
Accept: text/html,application/xhtml+xml  
Accept-Encoding: gzip, deflate  
Cache-Control: max-age=0  
Connection: keep-alive  
Host: www.ru  
User-Agent: Mozilla/5.0 Gecko/20100101 Firefox/39.0  

##### Отличия протокола HTTP/1.1 от HTTP/1.0:
* стало больше заголовков
* поддерживаются относительные пути  
  Из-за этого необходимо передавать заголовок **Host**  
  Это сделано для упрощения работы серверов, когда на одной машине работает несколько серверов (например, актуально для виртуального хостинга)
* позволяет управлять соединением с помощью заголовка **Connection*

#### Структура HTTP запроса
* строка запроса
  * метод
  * URL документа
  * версия
* заголовки
* пустая строка - разделитель
* тело запроса

### HTTP/1.1 ответ
HTTP/1.1 404 Not Found  
Server: nginx/1.5.7  
Date: Sat, 25 Jul 2015 09:58:17 GMT  
Content-Type: text/html; charset=iso-8859-1  
Connection: close

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">  
<HTML><HEAD>...

* Версия HTTP протокола: сервер и клиент должны работать одинаковой версии  
  Т.е. если сервер не поддерживает HTTP/1.1, в отличие от клиента, то клиент должен понизить версию до HTTP/1.0
* *404 Not Found* - код ответа (результат операции) и его расшифровка
* Далее идут заголовки ответа
  * Среди заголовков ответа есть обязательный заголовок: **Content-Type** - тут указывается **MIME-тип**и (опционально) **кодировка документа**
* После заголовков идет **пустая строка** как разделитель заголовков и тела ответа
* Длина ответа:
  * Длину сообщения можно не указывать, если установлен заголовок **Connection: close**
  * Длину сообщения *необходимо указать*, если установлен заголовок **Connection: keep-alive**  
    Длина задается с помощью заголовка **Content-Length** в байтах

#### Структура HTTP ответа
* строка ответа
  * метод
  * URL документа
  * версия
* заголовки
* пустая строка - разделитель
* тела ответа - документ

### HTTP методы
* **GET** - получение документа
* **HEAD** - получение только заголовков и статуса ответа  
  Используется для кеширования (проверки обновления), для работы ботов-поисковиков, для проверки существования/обновления сущностей (например в Rest-API).  
  Позволяет уменьшить расход трафика.
* **POST** - отправка данных на сервер
* PUT - отправка документа целиком на сервер (*обычно отключен на публичных серверах*)  
  Загрузка документа с присвоением ему переданного в строке запроса URL.
* DELETE - удаление документа (*обычно отключен на публичных серверах*)
* CONNECT, TRACE, OPTIONS - используются редко (*обычно отключен на публичных серверах*)
* *COPY, MOVE, MKCOL* - расширения WebDAV (*обычно отключен на публичных серверах*)

### HTTP коды ответа
* **1xx** - информационные
* **2xx** - успешное выполнение
* **3xx** - перенаправления
* **4xx** - ошибка на стороне клиента
* **5xx** - ошибка на стороне сервера

### Заголовки HTTP (общие)
* Content-Type - MIME тип документа
* Content-Length - длина сообщения
* Content-Encoding - кодирование документа, например gzip-сжатие
* Transfer-Encoding - формат передачи, например, chunked
* Connection - управление соединением
* Upgrade - смена протокола текущего соединения

### Заголовки HTTP запросов
* Authorization - авторизация, чаще всего логин/пароль
* Cookie - передача состояния (сессии) на сервер
* Referer - URL предыдущего документа, контекст запроса
* User-Agent - описание web-клиента, версия браузера
* If-Modified-Since - (условный GET запрос) передается время, когда документ был закеширован, используется для проверки обновления документа
* Accept-\* - согласование (negotiation) содержимого  
  Тут перечиляются опции документа, поддерживающиеся браузером

### Заголовки HTTP ответов
* Location - новый URL документа при перенаправлениях
* Set-Cookie - установка состояния (сессии) в браузере
* Last-Modified - дата последнего изменения документа
* **Date** - дата на сервере, для согласования кешей (*актуально для любой распределенной системы*)
* Server - описание web-сервера, название и версия

## BEST PRACTICE (авторизация)
 1. Пользователь **авторизуется** на сервере, передавая в запросе пароль и логин (*зашифрованные*) на сервер с помощью заголовка **Authorization**
 2. Сервер **аутентифицириет** его по логину и паролю
 3. Сервер отправляет ответ на запрос с занесением в **Set-Cookie** идентификатора сессии пользователя (например, *временный guid пользователя*)
 4. Пользователь использует идентификатор в запросах на сервер (передавая его в заголовке **Cookie*
 5. Сервер по идентфиикатору в запросе **идентифицирует** пользователя
 

## HTTP/1.1 Управление соединением (персистенное соединение)

HTML страницы часто загружается медленно из-за задержек на "рукопожатия" в TCP (и в TLS).

Поэтому в HTTP/1.1 было добавлено управление соединением, позволяющее не закрывать соединение после запроса, тем самым не тратя на следующем запросе-ответе время на установление TCP (и TLS) соедиенение.

### Общие принципы
* Протокол HTTP/1.0 предполагает **закрытие TCP соединения** сразу после ответа сервера.
* Протокол HTTP/1.1 предполагает **удержание открытого TCP соединения**, если не было заголовка ***Connection: close***.  
  Если ***Connection: close*** не передается, то соедиенение останеться открытым  

### Логика управления в HTTP/1.1
Соединение должно быть закрыто, если:
* cервер или клиент использует HTTP младше 1.1
* cервер или клиент передал заголовок ***Connection: close***
* по истечении таймаута (обычно небольшой, около 10с)

*Иначе:* соединение остается открытым для последующих запросов.

### Новые протоколы
Сейчас существуют новые версии протокола HTTP, предназначенные для работы с персистентными соединениями:
* **Speedy** (от Google)
* **HTTP/2.0**
