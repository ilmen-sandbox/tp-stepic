# Web-приложения

Frontend берет на себя обработку HTTP запроса.  
При передаче запроса в backend сервер получает вместе с запросом подготовленное frontend окружение (WSGI окружение).  
Backend серверу остается лишь выполнить свои задачи.

## Основные задачи backend
* Маршрутизация URL (выбор подходящей функции)
* Парсинг заголовков и параметров запроса
* Хранение состояния (сессии) пользователя (распределенное между backend серверами)
* Выполнение бизнес-логики
* Работа с базами данных, хранилищами и сторонними сервисами
* Генерация HTML страницы или JSON ответа

## MVC
**MVC** (Model, View, Controller) - архитектурный паттерн.

MVC - середний пласт webframework'ов, между простыми (например, для упрощенного парсинга заголовков) и монструозными (где необходимо лишь подставить функции в готовый шаблон, например, .NET WebService)

### Схема работы MVC
![mvc_pattern](https://github.com/ilmen/tp-stepic/blob/master/lesson-9/pictures/mvc_detail.png "MVC как архитектурный паттерн в WSGI приложениях")

### Роли компонентов MVC приложения
* **Framework** (Middle Layer) - "обертка" над нашим MVC приложением, которая на каждый запрос вызывает с помошью **Router** подходящий под URL **Controller** и возращает его ответ серверу в виде документа
* **Router** - отображение URL'ов на контроллеры приложения
* **Controller** (точка входа в приложение) - работа с HTTP, связыет **Controller**, **Model** и **View**  
  * Транслирует запрос во входные параметры вызываемых методов модели
  * Вызывает методы **Model**
  * Получает от **Model** данные для отображения документа и передает их во **View**
  * Получает от **View** документ и отдает его в **Framework** в качестве ответа сервера
* **Model** - *полностью* реализует *всю* бизнес-логику приложения, возвращает данных для всех **View**  
  Бизнес-логика: все вычисления, запросы к БД, запросы к сторонним сервисам, использование классов-helper'ов
* **View** - функция для представления данных в необходимом формате (HTML, JSON, XML и т.п.)   
  P.S. Иногда **View** может вызовать методы **Model** и/или **Controller**. *Это спорная практика.*

### Популярные MVC-фраймворки
* Django (Python)
* Ruby-On-Rails (Ruby)
* YiiFramework (PHP)
* ASP.NET MVC

### Плюсы MVC-фреймворков
➕ Готовая архитектура (меньше шансов "выстрелить себе в ногу")  
➕ Повторное использование кода  
➕ Экономия ресурсов  
➕ Участие в Open Source  
➕ Проще найти программистов  
➕ Проще обучать новых в проекте программистов  

## Django
### Соглашение о именовании
***Внимание: ***в Django ***views*** - это классический MVC **Controller**!

> * ***Model*** -> (MVC) Model
> * ***urls.py*** -> (MVC) Router
> * ***views*** -> (MVC) Controller
> * ***templates*** -> (MVC) View

***Т.е. говоря в будущем "вью", "вьюшка" в контексте Django - мы имеем в виду Django-Сontroller!***

### Создание проекта
> **django-admin startproject project** - создание проекта.

### Структура проекта (open-source)
![django_project_struct](https://github.com/ilmen/tp-stepic/blob/master/lesson-9/pictures/django_project_struct.png "Структура проекта Django (open-source)")

Корневая директория "projectName" - **директория проекта**  
Все папки первого уровня - **директории приложений**  
Вложенная папка "projectName" - **директория web-приложения**  
Файл **manage.py** - файл для администрирования приложения (см. далее)  

### Основные файлы проекта
* **manage.py** - скрипт управления проектом
* **project/settings.py** - настройки
* **project/urls.py** - router, список URL проекта
* **project/wsgi.py** - WSGI приложение, точка входа
* **crm** - Django-приложение

## Django-приложения
В Django есть концепция "приложение=модуль".  
Она позволяет разбить все web-приложение на небольшие модули - Django-Application (например, приложение в папке **crm** на предыдущем рисунке).  
Такие приложения можно распространять, подключать подобно модулям и переиспользовать в других проектах.  

**Django-приложения** - способ распространения кода в Django инфраструктуре.  
В случае, если вы планируете публиковать ваш код, приложения - это удобный способ логической организации кода.

> **./manage.py startapp crm** - создание нового приложения с именем **crm** . *Нужно вызывать из директории проекта.*

### Структура Django-приложения
![django_application_struct](https://github.com/ilmen/tp-stepic/blob/master/lesson-9/pictures/django_application_struct.png "Структура Django-приложения")

### Основные файлы Django-приложения
* **models.py** - файл с моделями, бизнес-логика  
  Если бизнес-логика сложная, то есть смысл разбить ее на несколько файлов вида "models_....py" и объединить их внутри "models.py"
* **views.py** - контроллеры
* **urls.py** - URL роутер данного приложения
* **management/commands** - консольные команды приложения  
  позволяют использовать web-приложение как приложение командной строки, например для миграции версии БД и т.п.
* **templates** - директория с шаблонами (в не open-source распологается в директории проекта, а не директории приложения)
* **static** - CSS, JavaScript, картинки (в не open-source распологается в директории проекта, а не директории приложения)
* **migrations** - миграции для обновления базы данных и т.п. при смене версии приложения
* **templatetags** - позволяет задавать **расширения и кастомные теги для шаблонизатора Django**

**Имена директорий и файлов приложения, которые нельзя менять:**
* templatetags
* management/commands
* migrations
* models.py

### Итоговая структура проекта (не open-source)
Если отказаться от использования концепции "приложение=модуль", то удобнее всего использовать такую структуру проекта:

![not_open_source_django_struct](https://github.com/ilmen/tp-stepic/blob/master/lesson-9/pictures/django_not_open_source_project_struct.png "Структура проекта Django (не open-source)")


## Конфигурация Django
### Конфигурация Django - просто Python модуль
![django_settings](https://github.com/ilmen/tp-stepic/blob/master/lesson-9/pictures/settings.png "Конфигурация Django")

### Переменные конфигурации Django
[Список переменных конфигурации Django](https://github.com/ilmen/tp-stepic/blob/master/synopses/DjangoVariables.md)

### Пути в конфиге
**Проблемы:**
* Проект может быть развернут в любой директории
* Несколько копий проекта на одном сервере

**Решения:**
* Абсолютные пути в каждом конфиге (*плохой вариант, особенно если проект в GIT*)
* Переменные окружения, $PROJECT_PATH (*легко забыть задать*)
* Относительные пути

### Относительные пути
![relative_paths](https://github.com/ilmen/tp-stepic/tree/master/lesson-9/pictures/relative_paths.png "Относительные путь в конфигурации")

**__file__** - полный путь к исполняему сейчас файлу-скрипту (на рисунке сверху - путь к settings.py).

## BEST PRACTICE (паттерн local_settings.py)
Настройки проекта можно условно поделить на две группы: статичные (редко изменяемые) и часто изменяемые. 
Рядом с **settings.py** помещаем файл **local_settings.py**.  
Файл **local_settings.py** исключаем из GIT (например, с помощью .gitignore)
В конце основного файла настроек (**settings.py**) помещаем код, который импортирует настройки из **local_settings.py**:
> \# в конце project/settings.py
> try:
> __from ask_pupkin.local_settings import *
> except ImportError:
> __pass

Использование: в файле **settings.py** помещаем настройки для "боевого сервера", в файле **local_settings.py** перекрываем основные настройки настройками для отладки на машине разработчика (аналог machine.config и web.config).

## Маршрутизация URL
### Порядок поиска контроллера
* Django начинает поиск с файла **ROOT_URLCONF** из настроек
* При успешной загрузке файла, Django использует переменную **urlpatterns** из файла
* Django проходит по всем паттернам до первого совпадения
* Если совпадения не найдено - будет возвращен код **404 Not Found**

### Содержимое urls.py
![urlpatterns](https://github.com/ilmen/tp-stepic/tree/master/lesson-9/pictures/urlpatterns.png "Содержимое urls.py")

В функцию **url** передается несколько аргументов:
1. Регулярное выражение для парсинга URL
2. Объект-обработчик запроса  
  * Предается имя функции (например, *'blog.views.home'* - функция home из файла views из приложения blog)
  * сама функция (при формировании urlpatterns с помощью функции patterns)
  * другой файл urls.py, т.о. образуется деревовидный маршрутизатор запросов (например, *include('blog.urls')*)
3. name - имя маршрута (для логической организации)

Функция ***patterns(...)*** формирует такой же список маршрутов, как и на предыдущей картинке, но еще **добавляет** ко всем именам функции заданные **префикс** переданный в функцию как **первый входной параметр** (подробнее в видео *5. Маршрутизация URL*).  
При использовании функции ***patterns*** возможно **явное указание** функции-обработчика запроса (а не через ее строковое имя).  

### BEST PRACTICE (по формировании urlpattenrs)
* При задании в urlpatterns функции в виде *строкового имени* используется механизм *Lazy Loading*.  
  Т.е. функция загружается только в момент обращения по данному URL пользователя и пользователь получит ошибку с кодом **500**.  
* При использовании *явного указания на функцию* (через ф-ию patterns) web-приложение не сможет запуститься, если функция не будет найдена, **т.е. администратор сможет заблаговременно обнаружить и исправить ошибку**, что передпочтительнее.

### Захват переменных из URL
Django позволяет захватывать из URL перемененные и передавать их функции-обработчику.  
Например:  
 Маршрут **url(r'blog/(?P<blog_name>[^/]+)/post/(?P<title>[^/]+)/?', post_details)** позволяет перехватывать все URL вида 
 **/blog/blog_name/post/title**, где **blog_name** и **title** меняются для каждого блога и поста соответственно и позволяет захватить **blog_name** и **title** в одноименные переменные.

### Функции
* url - конструктор именованных маршрутов URL>функция
* patterns - тонкая обертка для добавления префиксов к имени функции
* include - позволяем включать один файл urls.py в другой для огранизации древовидного списка маршрутов

### Особенности маршрутизации в Django
* Слеш (**/**) в начале роутов не указывается (например, главная страница сайта: ***r'^$'*** - пустой URL)
* Можно указывать как имя, так и саму view-функцию
* Роуты описываются с помощью регулярных выражений
* Можно и нужно разносить роуты по приложениям
* Можно и нужно создавать именованные роуты
* **Одно действие – один роут – один контроллер**
 
### BEST PRACTICE (организации кода в контроллерах)
**Одно действие – один роут – один контроллер**

### BEST PRACTICE (разнесение роутов по приложениям)
Разносим маршруты каждого приложения в отдельный файл urls.py и внедряим их в общий список маршрутизации с помощью ф-ии include.  
Таким образом, получаем древовидный список маршрутов, которой выигрывает по производительности и более удобен при командной разработке.  
Производительность: древовидный список быстрее плоского, т.к. в плоском на каждый запрос пришлось бы анализировать все регулярные выражения предыдущих по списку приложений, даже если это маршруты из других доменов.

### Reverse routing (ссылание из гипертекстового документа на другие документы сервера)
Часто на странице необходимо поместить ссылку на какой либо документ с сервера (например, ссылка из списка статей на документ статьи).

Такую ссылку можно задать жестко в шаблоне, *но это плохой путь* (например, страдает переносимость приложения).  
Для автоматического создания относительных путей используется **reverse routing**.  
Необходимо использовать **именованные** маршруты (задавая передавая поле **name** в функцию **url**, см. схему urlpatterns)

![reverse_routing](https://github.com/ilmen/tp-stepic/tree/master/lesson-9/pictures/reverse_routing.png "Reverse routing")
* reverse('home') преобразуется в '/'
* reverse('post-detail', kwargs={'pk': 7}) преобразуется в '/blog/post/7'
