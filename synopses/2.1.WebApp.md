# Web-приложения

Frontend берет на себя обработку HTTP запроса.  
При передаче запроса в backend сервер получает вместе с запросом подготовленное frontend окружение (WSGI окружение).  
Backend серверу остается лишь выполнить свои задачи.

## Основные задачи backend
* Маршрутизация URL (выбор подходящей функции)
* Парсинг заголовков и параметров запроса
* Хранение состояния (сессии) пользователя (распределенное между backend серверами)
* Выполнение бизнес-логики
* Работа с базами данных, хранилищами и сторонними сервисами
* Генерация HTML страницы или JSON ответа

## MVC
**MVC** (Model, View, Controller) - архитектурный паттерн.

MVC - середний пласт webframework'ов, между простыми (например, для упрощенного парсинга заголовков) и монструозными (где необходимо лишь подставить функции в готовый шаблон, например, .NET WebService)

### Схема работы MVC
![mvc_pattern](https://github.com/ilmen/tp-stepic/blob/master/lesson-9/pictures/mvc_detail.png "MVC как архитектурный паттерн в WSGI приложениях")

### Роли компонентов MVC приложения
* **Framework** (Middle Layer) - "обертка" над нашим MVC приложением, которая на каждый запрос вызывает с помошью **Router** подходящий под URL **Controller** и возращает его ответ серверу в виде документа
* **Router** - отображение URL'ов на контроллеры приложения
* **Controller** (точка входа в приложение) - работа с HTTP, связыет **Controller**, **Model** и **View**  
  * Транслирует запрос во входные параметры вызываемых методов модели
  * Вызывает методы **Model**
  * Получает от **Model** данные для отображения документа и передает их во **View**
  * Получает от **View** документ и отдает его в **Framework** в качестве ответа сервера
* **Model** - *полностью* реализует *всю* бизнес-логику приложения, возвращает данных для всех **View**  
  Бизнес-логика: все вычисления, запросы к БД, запросы к сторонним сервисам, использование классов-helper'ов
* **View** - функция для представления данных в необходимом формате (HTML, JSON, XML и т.п.)   
  P.S. Иногда **View** может вызовать методы **Model** и/или **Controller**. *Это спорная практика.*

### Популярные MVC-фраймворки
* Django (Python)
* Ruby-On-Rails (Ruby)
* YiiFramework (PHP)
* ASP.NET MVC

### Плюсы MVC-фреймворков
➕ Готовая архитектура (меньше шансов "выстрелить себе в ногу")  
➕ Повторное использование кода  
➕ Экономия ресурсов  
➕ Участие в Open Source  
➕ Проще найти программистов  
➕ Проще обучать новых в проекте программистов  

## Django
### Соглашение о именовании
***Внимание: ***в Django ***views*** - это классический MVC **Controller**!

> * ***Model*** -> (MVC) Model
> * ***urls.py*** -> (MVC) Router
> * ***views*** -> (MVC) Controller
> * ***templates*** -> (MVC) View

***Т.е. говоря в будущем "вью", "вьюшка" в контексте Django - мы имеем в виду Django-Сontroller!***

### Создание проекта
> **django-admin startproject project** - создание проекта.

### Структура проекта (open-source)
![django_project_struct](https://github.com/ilmen/tp-stepic/blob/master/lesson-9/pictures/django_project_struct.png "Структура проекта Django (open-source)")

Корневая директория "projectName" - **директория проекта**  
Все папки первого уровня - **директории приложений**  
Вложенная папка "projectName" - **директория web-приложения**  
Файл **manage.py** - (так ли?)файл для администрирования приложения, содержит все предварительные проверки и операции перед запуском приложения  

### Основные файлы проекта
* **manage.py** - скрипт управления проектом
* **project/settings.py** - настройки
* **project/urls.py** - router, список URL проекта
* **project/wsgi.py** - WSGI приложение, точка входа
* **crm** - Django-приложение

## Django-приложения
В Django есть концепция "приложение=модуль".  
Она позволяет разбить все web-приложение на небольшие модули - Django-Application (например, приложение в папке **crm** на предыдущем рисунке).  
Такие приложения можно распространять, подключать подобно модулям и переиспользовать в других проектах.  

**Django-приложения** - способ распространения кода в Django инфраструктуре.  
В случае, если вы планируете публиковать ваш код, приложения - это удобный способ логической организации кода.

> **./manage.py startapp crm** - создание нового приложения с именем **crm** . *Нужно вызывать из директории проекта.*

### Структура Django-приложения
![django_application_struct](https://github.com/ilmen/tp-stepic/blob/master/lesson-9/pictures/django_application_struct.png "Структура Django-приложения")

### Основные файлы Django-приложения
* **models.py** - файл с моделями, бизнес-логика
* **views.py** - контроллеры
* **urls.py** - URL роутер данного приложения
* **templates** - директория с шаблонами
* **management/commands** - консольные команды приложения
* **static** - CSS, JavaScript, картинки
* **migrations** - миграции для обновления базы данных

### Итоговая структура проекта (не open-source)
Если отказаться от использования концепции "приложение=модуль", то удобнее всего использовать такую структуру проекта:

![not_open_source_django_struct](https://github.com/ilmen/tp-stepic/blob/master/lesson-9/pictures/django_not_open_source_project_struct.png "Структура проекта Django (не open-source)")


## Конфигурация Django
### Конфигурация Django - просто Python модуль
![django_settings](https://github.com/ilmen/tp-stepic/blob/master/lesson-9/pictures/settings.png "Конфигурация Django")

### Переменные конфигурации Django
[Список переменных конфигурации Django](https://github.com/ilmen/tp-stepic/blob/master/synopses/DjangoVariables.md)

### Пути в конфиге
**Проблемы:**
* Проект может быть развернут в любой директории
* Несколько копий проекта на одном сервере

**Решения:**
* Абсолютные пути в каждом конфиге (*плохой вариант, особенно если проект в SVC*)
* Переменные окружения, $PROJECT_PATH (*легко забыть задать*)
* Относительные пути

### Относительные пути
![relative_paths](https://github.com/ilmen/tp-stepic/tree/master/lesson-9/pictures/relative_paths.png "Относительные пуьт в конфигурации")

**__file__** - полный путь к исполняему сейчас файлу-скрипту (на рисунке сверху - путь к settings.py).

## BEST PRACTICE (паттерн local_settings.py)
Настройки проекта можно условно поделить на две группы: статичные (редко изменяемые) и часто изменяемые. 
Рядом с **settings.py** помещаем файл **local_settings.py**.  
В конце основного файла настроек (**settings.py**) помещаем код, который импортирует настройки из **local_settings.py**:
> # в конце project/settings.py
> try:
> __from ask_pupkin.local_settings import *
> except ImportError:
> __pass

Использование: например, чтобы разработчики не мешали друг другу при использовании разных БД при отладки в командной разработке.


